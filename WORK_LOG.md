Name: YOUR NAME HERE

| Date         |     Time      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Update |
|:-------------|:-------------:|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| April 5      |    9-10pm     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    I tried to write abstract, efficient code. |
| September 25 |  1:50-2:30pm  |                                                                                                                                                                                                                                                       Right now I'm thinking of approaching the problem by turning the entire dictionary into a tree, where the children of each node are words that are built off of the original word. I'm not really sure how to keep track of where to go back to when I've exhausted one lineage though. |
| September 25 |  2:30-3:00pm  |                                                                                                                                                                                                                                I spent a lot of time caught up on how to deal with single letter words. Then I talked to Mr. Blick and realized that I should just treat them like any other word, and if one of them doesn't exist, such as "b", just wait till i get something that starts with "b" and then make the path that includes b. |
| September 26 |  8:10-8:40pm  |                                                                                     I think my search tree is building correctly with only words with normal letters. Have not yet added apostrophes. Now I'm working on searching that tree to check if a word is a valid word or not. My plan is to go letter by letter, traversing the tree until I reach a null letter, or until I have traversed the whole word. If its null, i'll just return false, but if i've traversed the whole word, I'll then check if the word is valid or not. |
| September 26 |  8:40-9:10pm  |                                                                                                                                                    I passed testSentence! It took a lot of debugging, but I got my search function to work. For a while I was adding every word, because I wasn't checking the validity of the word at the end of the word, I was checking it at every letter. Also, I kept adding a bunch of copies of the same words because I wasn't breaking out of my for loop. With these fixed, I passed testSentence. |
| September 26 |  9:10-9:40pm  |                                                                  More progress! I added in checking for apostrophes, and am still working out filtering out words which have strange characters like accents and whatnot. Also, my way of checking for duplicates is not very good right now. It scales with how many words are already incorrect, which worsens with time. My plan is to implement a variable associated with each node which will store whether it's been added to the list yet, which should give me constant time lookup. |
| September 26 | 9:40-10:10pm  |                                              I spent basically the entire time trying to deal with this pesky 'Ã¦' character. I'm still not totally sure why it wasn't working, I basically just hardcoded it out. The reason it took so long is because running the debugger is very slow when I have to stop at the 18000th loop, and check the index everytime. I still have my runtime issue which I think I can solve with that constant time lookup as I was talking about above, but I did pass the test in everything except the time. |
| September 26 | 10:10-10:40pm |                                                                                                                                                                                                                                                             So this is funny. It turns out storing the constant time lookup in the nodes doesn't work, becuase the nodes aren't the words being checked...duh. But in trying to find a solution, I came across LinkedHashSet, which seems a lot like the hash tables we talked about in class |
| September 30 |  5:30-6:15pm  |                                                                                                                                                                                                         I reverted back to using a search tree, which we learned is actually called a trie. However, I abstracted the trie itself into a separate object. This way, it's easy to also use a trie to store misspelled words to make sure I don't return duplicates. The solution with tries is now fully implemented and passes all the tests. |
| October 2    | 10:30-11:30pm |                                                                                                                                                                                                                                              I spent a long time trying to implement TST. To be honest, I'm really stuck. It's really hard for me to wrap my head around for some reason. I spent about an hour, so I'll shelve it for now. Everything I try ends in null pointers, so maybe I'm just approaching the problem entirely wrong. |
| October 3    |  8:45-9:55pm  |                                                                                                                                                                TST is almost working! there's a strange issue where I'm not detecting every single word that is misspelled, but it is working for most cases. I'm approaching the problem recursively, shortening the word every time there is a middle child, but leaving it the same if creating a left or right child. The base cases were tricky, but i figured out something that works. |
| October 6    |  4:30-5:00pm  | Spent a long time trying to fix my bug where I wasn't detecting every misspelled word. I was getting maybe 90% of them. I combed through my insert function a bunch, before realizing that I actually probably had to do with my lookup function. I figured out that words which were one letter more than a valid word, such as "mome" (mom + e) were returning true, but I fixed that, and now it works great. Interestingly TST runs slower than Trie on my computer. I have some pretty good memory though, which is probably the reason. |
| October 7    | 10:15-10:45pm |                                                                                                                                                                                                                                                                                                                                                                                                                   Went through and commented all my code, did a few last check to see if I could improve efficiency. Spell Check is complete! |
                                                                                                                                                                                                                                                                                      


To add a new row to the table, click into a cell and then hit shift-enter.